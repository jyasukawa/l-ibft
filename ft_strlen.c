#include "libft.h"

size_t	ft_strlen(const char *s)
{
	size_t	i;

	i = 0;
	while (s[i])
		i++;
	return (i);
}

// #include <string.h>
// #include <stdio.h>
// int main(){
// 	char *sf = "";
// 	char *so = "";
// 	printf("%zu\n", ft_strlen(sf));
// 	printf("%lu\n", strlen(so));
// 	printf("\n\n");
// 	char *sf2 = NULL;
// 	char *so2 = NULL;
// 	printf("%zu\n", ft_strlen(sf2));
// 	printf("%lu\n", strlen(so2));
// }

// <レビューコメント>
// セグフォ対策として0を戻していましたが、基本的に未定義のままであるものが0となっているよりかはセグフォした方が良さそう
// 入力 *s == 0(NULL) ならば停止(=segmentation fault)するのはオリジナルと同じです

// ＜ポインタへのconst３パターンについて＞
// 指定①：”ポインタが指す先” を変更不可にする
// * の後ろ側で const を指定することで、“ポインタが指す先” を変更不可にすることができます
// int a = 10, b = 20;
// int * const p = &a;
// p = &b; /* コンパイルエラー */
// ただし、”ポインタが指す先” の変更はできませんが、そのポインタの指す先のデータに関しては変更可能です。
// int a = 10, b = 20;
// int * const p = &a;
// *p = 100; /* aの値が100になる */
// 指定②：”ポインタが指すデータ” を変更不可にする
// * の前側で const 指定することで、“ポインタが指すデータ” を変更不可にすることができます。型名の前側・後ろ側のどちらに const を記述しても問題ありません
// int a = 10, b = 20;
// const int *p = &a;
// *p = 100; /* コンパイルエラー */
// この場合は、ポインタが指す先自体は変更可能です。
// int a = 10, b = 20;
// const int *p = &a;
// p = &b; /*pはbを指す */
// 指定③：両方を変更不可にする
// さらに、* の前後両方に対して const を指定することで、“ポインタが指す先” と “ポインタが指すデータ” の両方を変更不可にすることができます。
// int a = 10, b = 20;
// const int * const p = &a;
// p = &b; /* コンパイルエラー */
// *p = 100; /* コンパイルエラー */

// ＜const修飾は使ったほうがいいのか＞
// すべて値を書き換え可能にしておくと、デバッグが容易になるからconstを使わない開発者も一定数います
// constは基本的には使ったほうが良いものです
// ミスや事故による意図しない変数の値の書き換えが起こらないようにconstを付けておくのは設計の基本と言えます。

// ＜constをつける位置＞
// const char *const s = "abc";
// char const *const s = "abc";
// このconstの書く位置と言うのは開発者によって異なっています。

// ＜constをはずす場合＞
// C言語の変数についているconstは外すことができます。
// 具体的にはキャストで無理やり外します。
// より具体的に言うと、変更してもコンパイル時にエラーが発生しなくなります。
// ただし、暗黙的なキャストの場合はまだ救いがあります。
// これは、const 指定が外されるような暗黙的なキャストが発生した場合、コンパイル時に警告が出力されるからです。
// constを無理やり外すキャストは一般的にはあまり好まれていません。
// なぜかというと、constを無理やり外すケースと言うのは設計が破綻している場合が多いからです。
// 。。。そもそもはずさないためのconstのはずだから