#include "libft.h"

void	*ft_memmove(void *dst, const void *src, size_t len)
{
	if (dst == NULL && src == NULL)
		return (NULL);
	if ((unsigned char *)dst < (const unsigned char *)src)
		return (ft_memcpy(dst, src, len));
  while (len > 0)
  {
    len--;
    ((unsigned char *)dst)[len] = ((const unsigned char *)src)[len];
  }
	return (dst);
}

// #include <string.h>
// #include <stdio.h>
// void	*ft_memcpy(void *dst, const void *src, size_t n)
// {
// 	size_t	i;

// 	if (dst == NULL && src == NULL)
// 		return (NULL);
//   i = 0;
// 	while (i < n)
// 	{
// 		((unsigned char *)dst)[i] = ((const unsigned char *)src)[i];
// 			i++;
// 	}
// 	return (dst);
// }
// int main(){
//   char sf[] = "Hello, world!";
//   printf("Before: %s\n", sf);
//   ft_memmove(sf + 7, sf + 5, 7);
//   printf("After: %s\n", sf);
//   printf("\n");
//   char so[] = "Hello, world!";
//   printf("Before: %s\n", so);
//   memmove(so + 7, so + 5, 7);
//   printf("After: %s\n", so);
//   return(0);
// }

// ＜レビューコメント＞
// dst==srcのときdstを返します
// この中でmemcpyが使えるのでオススメ

// ＜メモ＞
// memcpyの進化版
// (len--)とすればいいところを行数に余裕があったので分けて書くことにより、少しでも可読性を上げる
// len != 0 ではなく、len > 0 とすることで、size_tであることの注意喚起
// elseを使わなくていいよう、即時return&&()の中に関数呼び出し
// dst==srcのとき未定義なmemcpyに入らないようにした。
// len--とすることで、len == 3の場合[2][1][0]のように埋まる
// 本当はsize_tをマイナス計算したくない
// ...オーバーラップ防止の為にデクリメントしてるから仕方ない？？
// (void *)を明示的にキャストした

// <void *型について>
// (void *) 型同士の比較演算は、C言語においては許可されています。しかし、その結果はポインタの値そのものを比較するものであるため、比較の意味が限定的であることに注意が必要です。以下はいくつかのポイントです
// 1.等号演算子（==）および不等号演算子（!=）: (void *) 型同士の比較では、等号演算子および不等号演算子を使用できます。これは、ポインタが同じメモリアドレスを指しているかどうかをチェックするために使用できます。
// ...==NULLチェックのときとか
// 2.大小比較: (void *) 型同士の大小比較は、C言語の標準では規定されていません。このため、 (void *) 型同士の大小比較は意味がないことが多いです。実際には、ポインタがどのデータ型を指しているかを考慮することが重要です。
// 3.ポインタの型情報の喪失: (void *) 型にキャストされたポインタは、元の型情報を喪失します。したがって、ポインタがどのデータ型を指しているかを保持している場合、それを (void *) 型として比較することで、型情報は無視されます。
// ポインタの比較を行う際には、ポインタが指すデータ型やメモリ領域の内容を考慮することが非常に重要です。 (void *) 型同士の比較は、ポインタの等値性をチェックするために使われることがありますが、型情報やメモリ内容に基づく比較には向いていません。そのため、具体的なコンテキストに合わせて注意深く使用する必要があります。
// void * 型は、C 言語で言う「汎用ポインタ」とまったく同じで、全てのポインタを代入できます
// ポインタ型の void * 型へのキャストは、暗黙的に行えます
// このポインタ型は未知の型へのポインタとして用いることができるのです
// 当然ですが、間接参照を行うには明示的に型キャストしなければ使えません

// ＜キャストについて＞
// 変数 a のデータ型は条件式内でのみ一時的に long 型にキャストされたもので、その後は元の int 型のままです。つまり、a のデータ型は int ですが、条件式内では一時的に long に変換されて比較が行われます。
// なぜdstを二度も(unsigned char *)にキャストするのか...ifかelseどちらか片方、つまり一度しかキャストしてない
// ...間違い。一時的キャストは都度必要
// 同じデータ型に二度キャストを行うことは通常意味を持たずコードの可読性を損ねる可能性があります