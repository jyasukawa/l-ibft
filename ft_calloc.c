#include "libft.h"

void	*ft_calloc(size_t count, size_t size)
{
	void  *ptr;

	if (count == 0 || size == 0)
		return (ft_calloc(1, 1));
	if ((SIZE_MAX / count) < size)
	{
		errno = ENOMEM;
		return (NULL);
	}
	ptr = (void *)malloc(size * count);
	if (ptr == NULL)
	{
		errno = ENOMEM;
		return (NULL);
	}
    ft_bzero(ptr, (size * count));
	return (ptr);
}

// #include <stdio.h>
// void	*ft_memset(void *b, int c, size_t len)
// {
// 	size_t	i;

// 	i = 0;
// 	while (i < len)
// 	{
// 		((unsigned char *)b)[i] = (unsigned char)c;
// 		i++;
// 	}
// 	return (b);
// }
// void	ft_bzero(void *s, size_t n)
// {
// 	ft_memset(s, 0, n);
// }
// int main() {
//     size_t count = 5;
//     size_t size = sizeof(int);
//     int *arr = ft_calloc(count, size);
//     if (arr == NULL) {
//         perror("ft_calloc");
//         return 1;
//     }
//     printf("Memory allocated for %zu integers:\n", count);
//     for (size_t i = 0; i < count; i++) {
//         printf("%d ", arr[i]);
//     }
//     printf("\n");
//     free(arr);
//     return 0;
//     // このコードでは、ft_calloc 関数を呼び出して int 型の要素を5つ持つ配列を確保し、
//     // 確保されたメモリの内容を表示します。最後に、確保したメモリを free 関数を使用して解放します。
//     // このサンプルコードをコンパイルして実行すると、メモリ確保と解放の動作を確認できます。
// }

// <メモ>
// 一応先人に習って、引数どちらかが０のときに１バイトの領域を確保しつつ、mallocの引数が０になるケースも防ぐ
// (SIZE_MAX / count) < size...割り当てるメモリブロックのサイズがシステムがサポートする最大サイズを超えるかチェック
// (INT_MIN, INT_MIN) のような極端な引数で calloc を呼び出すと、不正な引数が渡されることになります。calloc 関数の引数は正の整数値でなければならないため、INT_MIN や負の数は無効な引数です。このような場合、関数の挙動は未定義です。プラットフォームやコンパイラによって異なる可能性があり、エラーメッセージやメモリリークの有無も予測できません。

// ＜SIZE_MAXについて＞
// SIZE_MAX と SIZE_T_MAX は非常に似ていますが、異なるものです。
// SIZE_MAX:
// SIZE_MAX は <stdint.h> ヘッダーで定義されており、符号なし整数型 (size_t) の最大値を表します。
// 通常、SIZE_MAX は size_t データ型の最大値として使用されます。
// size_t データ型は、システムに依存するサイズの符号なし整数型で、通常はメモリアロケーションなどで使用されます。
// SIZE_T_MAX:
// SIZE_T_MAX は標準Cライブラリでは直接定義されていないことが多く、通常は size_t の最大値を表すために SIZE_MAX を使用します。
// 言い換えれば、通常のプログラミング環境では、SIZE_MAX を size_t データ型の最大値として扱います。したがって、これらの値の間に実質的な違いはありません。

// ＜calloc関数とmalloc関数の引数の違い＞
// calloc関数とmalloc関数は引数の構成が違います。ただし、本質的にはメモリサイズを指定していることに違いはありません。
// long * pMem = (long *)malloc(sizeof(long) * 100);
// long * pMem = (long *)calloc(100, sizeof(long));
// 1つのデータサイズ x 個数が結局は確保サイズ
// 第１引数と第２引数は共にsize_t型のデータであり、この２つの引数は入れ替えても確保サイズに違いはありません

// ＜引数が０のとき＞
// calloc、malloc、および realloc 関数は、引数として 0 を受け入れます。 実際のメモリの割り当てはありませんが、有効なポインターが返され、メモリ ブロックは realloc によって後で変更できます。
// 要求された領域の大きさが 0 であるとき、その動作は処理系定義とする。ただし、null ポインタを返すか、又は 0 ではない大きさを要求したときと同じ動作(このとき、返されたポインタをオブジェクトのアクセスに使用してはならない)、のいずれかでなければならない。
// さらに、0 バイトが要求され、割り当て関数が正常終了したときに割り当てられる記憶域の容量は未規定である。
// 説明 malloc() 関数は size バイトを割り当て、 割り当てられたメモリーに対するポインターを返す。 メモリーの内容は初期化されない。 size が 0 の場合、 malloc() は NULL または free() に後で渡しても問題の起こらない一意なポインター値を返す。
// malloc,calloc 関数の引数のどちらかが 0 の場合、通常は新しい領域のメモリ割り当ては行われません。つまり、要求された要素数または要素のサイズが 0 の場合、calloc は NULL ポインタを返します。この動作は、無効なメモリ割り当てを防ぐためのセーフガードとして役立ちます。

// ＜なぜ１の容量を確保するのか＞
// calloc 関数が引数のいずれかが 0 の場合に 1 バイトの領域を確保するのは、C言語の仕様に従って設計されているからです。C言語の標準では、メモリ割り当て関数（malloc や calloc など）が引数が 0 の場合にも動作することが規定されています。
// この仕様の背後にはいくつかの理由があります：
// 一般的なインターフェースの維持: C言語のメモリ割り当て関数は、一般的なインターフェースを提供し、特定のケースで特別な処理をすることなく動作するように設計されています。引数が 0 の場合に 1 バイトの領域を割り当てることは、この一般的なインターフェースを維持するための方法の一つです。
// 特別なケースの最適化: 引数が 0 の場合に 1 バイトの領域を確保することにより、関数内部での特別なケースの処理を最適化できます。実際のメモリ割り当ては行われませんが、calloc 関数は NULL ポインタではないことを保証します。これにより、呼び出し元が返されたポインタをチェックせずに扱えます。
// 無駄なエラーチェックの回避: 引数が 0 の場合にエラーを返すか、特別な処理を行うかわずかなオーバーヘッドを避けることができます。通常のエラー処理パスに比べて効率的です。
// 一般的に、C言語のメモリ割り当て関数はエラーチェックを行い、適切なエラーコードを返すように設計されていますが、引数が 0 の場合に 1 バイトの領域を確保することはその一環です。このような特別な処理は、C言語のメモリ割り当て関数の設計において一般的です。
// calloc 関数の仕様では、どちらかの引数が 0 の場合、少なくとも 1 バイトの領域を確保することが保証されています。これは、特定のプログラムのエッジケースで、プログラマーが予測できるようにするためのものです。
// ptr は NULL ポインタではなく、実際にメモリアクセスが可能なポインタとなります。これによって、ゼロ除算やメモリ不足に関連するエラーを回避するのに役立ちます。
// ただし、この仕様に依存することは避け、明示的にプログラム内でゼロの場合の処理を行うことが推奨されます。それにより、コードがより明確になり、プログラムの安定性が向上します。

// ＜IBM＞
// 戻り値
// 正常に実行された場合、calloc() は、予約済みのメモリーのエリアを指すポインターを戻します。
// 要求を満たすのに十分なスペースがない場合、あるいは num または size が 0 の場合は、calloc() は NULL を戻します。calloc() は、十分なストレージがないために NULL を戻す場合は、errno を次のいずれかの値に設定します。
// エラー・コード
// 説明
// ENOMEM
// 使用可能メモリーが不十分です。
// malloc() 関数と calloc() 関数は、成功した場合は割り当てられたメモリへのポインタを返し、 それ以外の場合は NULL ポインタを返し errno を ENOMEM に設定します。